// @ts-check
// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import { Create as $Create } from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as matcher$0 from "./internal/matcher/models.js";

/**
 * ConnectionConfig represents connection settings
 */
export class ConnectionConfig {
    /**
     * Creates a new ConnectionConfig instance.
     * @param {Partial<ConnectionConfig>} [$$source = {}] - The source object to create the ConnectionConfig.
     */
    constructor($$source = {}) {
        if (!("url" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["url"] = "";
        }
        if (!("username" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["username"] = "";
        }
        if (!("password" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["password"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ConnectionConfig instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {ConnectionConfig}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new ConnectionConfig(/** @type {Partial<ConnectionConfig>} */($$parsedSource));
    }
}

/**
 * DiskFileInfo represents a file on disk for the frontend
 */
export class DiskFileInfo {
    /**
     * Creates a new DiskFileInfo instance.
     * @param {Partial<DiskFileInfo>} [$$source = {}] - The source object to create the DiskFileInfo.
     */
    constructor($$source = {}) {
        if (!("path" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["path"] = "";
        }
        if (!("name" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["name"] = "";
        }
        if (!("size" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["size"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new DiskFileInfo instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {DiskFileInfo}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new DiskFileInfo(/** @type {Partial<DiskFileInfo>} */($$parsedSource));
    }
}

/**
 * MatchInfo represents a single match for the frontend
 */
export class MatchInfo {
    /**
     * Creates a new MatchInfo instance.
     * @param {Partial<MatchInfo>} [$$source = {}] - The source object to create the MatchInfo.
     */
    constructor($$source = {}) {
        if (!("torrentFile" in $$source)) {
            /**
             * @member
             * @type {matcher$0.TorrentFileInfo}
             */
            this["torrentFile"] = (new matcher$0.TorrentFileInfo());
        }
        if (!("diskFiles" in $$source)) {
            /**
             * @member
             * @type {matcher$0.DiskFile[]}
             */
            this["diskFiles"] = [];
        }
        if (!("selected" in $$source)) {
            /**
             * @member
             * @type {matcher$0.DiskFile | null}
             */
            this["selected"] = null;
        }
        if (!("autoMatched" in $$source)) {
            /**
             * @member
             * @type {boolean}
             */
            this["autoMatched"] = false;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MatchInfo instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {MatchInfo}
     */
    static createFrom($$source = {}) {
        const $$createField0_0 = $$createType0;
        const $$createField1_0 = $$createType2;
        const $$createField2_0 = $$createType3;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("torrentFile" in $$parsedSource) {
            $$parsedSource["torrentFile"] = $$createField0_0($$parsedSource["torrentFile"]);
        }
        if ("diskFiles" in $$parsedSource) {
            $$parsedSource["diskFiles"] = $$createField1_0($$parsedSource["diskFiles"]);
        }
        if ("selected" in $$parsedSource) {
            $$parsedSource["selected"] = $$createField2_0($$parsedSource["selected"]);
        }
        return new MatchInfo(/** @type {Partial<MatchInfo>} */($$parsedSource));
    }
}

/**
 * MatchRequest represents a request to find matches
 */
export class MatchRequest {
    /**
     * Creates a new MatchRequest instance.
     * @param {Partial<MatchRequest>} [$$source = {}] - The source object to create the MatchRequest.
     */
    constructor($$source = {}) {
        if (!("torrentFiles" in $$source)) {
            /**
             * @member
             * @type {matcher$0.TorrentFileInfo[]}
             */
            this["torrentFiles"] = [];
        }
        if (!("diskFiles" in $$source)) {
            /**
             * @member
             * @type {matcher$0.DiskFile[]}
             */
            this["diskFiles"] = [];
        }
        if (!("requireSameExtension" in $$source)) {
            /**
             * @member
             * @type {boolean}
             */
            this["requireSameExtension"] = false;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MatchRequest instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {MatchRequest}
     */
    static createFrom($$source = {}) {
        const $$createField0_0 = $$createType4;
        const $$createField1_0 = $$createType2;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("torrentFiles" in $$parsedSource) {
            $$parsedSource["torrentFiles"] = $$createField0_0($$parsedSource["torrentFiles"]);
        }
        if ("diskFiles" in $$parsedSource) {
            $$parsedSource["diskFiles"] = $$createField1_0($$parsedSource["diskFiles"]);
        }
        return new MatchRequest(/** @type {Partial<MatchRequest>} */($$parsedSource));
    }
}

/**
 * MatchResponse represents the match results
 */
export class MatchResponse {
    /**
     * Creates a new MatchResponse instance.
     * @param {Partial<MatchResponse>} [$$source = {}] - The source object to create the MatchResponse.
     */
    constructor($$source = {}) {
        if (!("matches" in $$source)) {
            /**
             * @member
             * @type {MatchInfo[]}
             */
            this["matches"] = [];
        }
        if (!("unmatched" in $$source)) {
            /**
             * @member
             * @type {matcher$0.TorrentFileInfo[]}
             */
            this["unmatched"] = [];
        }
        if (!("totalFiles" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["totalFiles"] = 0;
        }
        if (!("matchedCount" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["matchedCount"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MatchResponse instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {MatchResponse}
     */
    static createFrom($$source = {}) {
        const $$createField0_0 = $$createType6;
        const $$createField1_0 = $$createType4;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("matches" in $$parsedSource) {
            $$parsedSource["matches"] = $$createField0_0($$parsedSource["matches"]);
        }
        if ("unmatched" in $$parsedSource) {
            $$parsedSource["unmatched"] = $$createField1_0($$parsedSource["unmatched"]);
        }
        return new MatchResponse(/** @type {Partial<MatchResponse>} */($$parsedSource));
    }
}

/**
 * RenameOperation represents a single rename operation
 */
export class RenameOperation {
    /**
     * Creates a new RenameOperation instance.
     * @param {Partial<RenameOperation>} [$$source = {}] - The source object to create the RenameOperation.
     */
    constructor($$source = {}) {
        if (!("oldPath" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["oldPath"] = "";
        }
        if (!("newPath" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["newPath"] = "";
        }
        if (!("torrentFile" in $$source)) {
            /**
             * @member
             * @type {matcher$0.TorrentFileInfo}
             */
            this["torrentFile"] = (new matcher$0.TorrentFileInfo());
        }
        if (!("diskFile" in $$source)) {
            /**
             * @member
             * @type {matcher$0.DiskFile}
             */
            this["diskFile"] = (new matcher$0.DiskFile());
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new RenameOperation instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {RenameOperation}
     */
    static createFrom($$source = {}) {
        const $$createField2_0 = $$createType0;
        const $$createField3_0 = $$createType1;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("torrentFile" in $$parsedSource) {
            $$parsedSource["torrentFile"] = $$createField2_0($$parsedSource["torrentFile"]);
        }
        if ("diskFile" in $$parsedSource) {
            $$parsedSource["diskFile"] = $$createField3_0($$parsedSource["diskFile"]);
        }
        return new RenameOperation(/** @type {Partial<RenameOperation>} */($$parsedSource));
    }
}

/**
 * RenameRequest represents a rename operation request
 */
export class RenameRequest {
    /**
     * Creates a new RenameRequest instance.
     * @param {Partial<RenameRequest>} [$$source = {}] - The source object to create the RenameRequest.
     */
    constructor($$source = {}) {
        if (!("matches" in $$source)) {
            /**
             * @member
             * @type {MatchInfo[]}
             */
            this["matches"] = [];
        }
        if (!("searchPath" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["searchPath"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new RenameRequest instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {RenameRequest}
     */
    static createFrom($$source = {}) {
        const $$createField0_0 = $$createType6;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("matches" in $$parsedSource) {
            $$parsedSource["matches"] = $$createField0_0($$parsedSource["matches"]);
        }
        return new RenameRequest(/** @type {Partial<RenameRequest>} */($$parsedSource));
    }
}

/**
 * TorrentFileInfo represents a file in a torrent for the frontend
 */
export class TorrentFileInfo {
    /**
     * Creates a new TorrentFileInfo instance.
     * @param {Partial<TorrentFileInfo>} [$$source = {}] - The source object to create the TorrentFileInfo.
     */
    constructor($$source = {}) {
        if (!("index" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["index"] = 0;
        }
        if (!("name" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["name"] = "";
        }
        if (!("size" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["size"] = 0;
        }
        if (!("progress" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["progress"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new TorrentFileInfo instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {TorrentFileInfo}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new TorrentFileInfo(/** @type {Partial<TorrentFileInfo>} */($$parsedSource));
    }
}

/**
 * TorrentInfo represents torrent information for the frontend
 */
export class TorrentInfo {
    /**
     * Creates a new TorrentInfo instance.
     * @param {Partial<TorrentInfo>} [$$source = {}] - The source object to create the TorrentInfo.
     */
    constructor($$source = {}) {
        if (!("hash" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["hash"] = "";
        }
        if (!("name" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["name"] = "";
        }
        if (!("size" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["size"] = 0;
        }
        if (!("progress" in $$source)) {
            /**
             * @member
             * @type {number}
             */
            this["progress"] = 0;
        }
        if (!("state" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["state"] = "";
        }
        if (!("savePath" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["savePath"] = "";
        }
        if (!("contentPath" in $$source)) {
            /**
             * @member
             * @type {string}
             */
            this["contentPath"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new TorrentInfo instance from a string or object.
     * @param {any} [$$source = {}]
     * @returns {TorrentInfo}
     */
    static createFrom($$source = {}) {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new TorrentInfo(/** @type {Partial<TorrentInfo>} */($$parsedSource));
    }
}

// Private type creation functions
const $$createType0 = matcher$0.TorrentFileInfo.createFrom;
const $$createType1 = matcher$0.DiskFile.createFrom;
const $$createType2 = $Create.Array($$createType1);
const $$createType3 = $Create.Nullable($$createType1);
const $$createType4 = $Create.Array($$createType0);
const $$createType5 = MatchInfo.createFrom;
const $$createType6 = $Create.Array($$createType5);
